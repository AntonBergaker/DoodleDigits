import { app, BrowserWindow, ipcMain } from "electron"
import {
    directory,
    loadSettingsOrDefault,
    loadStateOrDefault,
    saveSettings,
    CalculatorSettings,
    saveState,
    SaveStateData,
} from "./saving/saving"
import fs from "fs/promises"
import contextMenu from "electron-context-menu"
import { onIpc, sendIpc } from "./ipc/main-ipc"
import {
    themeFileToThemeData,
    ThemeData,
    getDefaultTheme,
} from "./saving/themes"

process.env.DEV_MODE = process.argv.includes("--dev") ? "true" : "false"

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
    app.quit()
}

const savedStatePromise = loadStateOrDefault()
let savedState: SaveStateData
const savedSettingsPromise = loadSettingsOrDefault()
let savedSettings: CalculatorSettings
let mainWindow: BrowserWindow

const availableThemes: { [key: string]: ThemeData } = {}
availableThemes["default"] = getDefaultTheme()

const themeDirectory =
    (process.env.DEV_MODE == "true" ? "./static" : process.resourcesPath) +
    "/themes/"

contextMenu({
    showSelectAll: true,
    showSearchWithGoogle: false,
    showInspectElement: false,

    append: (defaultActions, parameters, browserWindow) => [
        defaultActions.separator(),
        {
            label: "Always on Top",
            type: "checkbox",
            checked: savedSettings.always_on_top,
            click: (item, window, event) => {
                savedSettings.always_on_top = !savedSettings.always_on_top

                item.checked = savedSettings.always_on_top
                mainWindow.setAlwaysOnTop(savedSettings.always_on_top)

                sendIpc(window, "updateSettings", savedSettings)
                saveSettings(savedSettings)
            },
        },
    ],
})

const createWindow = async () => {
    savedSettings = await savedSettingsPromise

    let theme: ThemeData
    let themeFile: string

    if (savedSettings.theme != "default") {
        try {
            themeFile = await fs.readFile(
                `${themeDirectory + savedSettings.theme}/${
                    savedSettings.theme
                }.json`,
                "utf8"
            )
            theme = themeFileToThemeData(
                savedSettings.theme,
                JSON.parse(themeFile)
            )
        } catch {
            theme = getDefaultTheme()
        }
    } else {
        theme = getDefaultTheme()
    }

    savedState = await savedStatePromise

    const size = savedState.window_dimensions
    // Windows and MacOS get custom titlebar
    const customTitlebar =
        process.platform == "win32" || process.platform == "darwin"

    // Create the browser window.
    mainWindow = new BrowserWindow({
        height: size.y,
        width: size.x,
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
            sandbox: false,
        },
        autoHideMenuBar: true,
        titleBarStyle: customTitlebar ? "hidden" : "default",
        frame: !customTitlebar,
        titleBarOverlay: {
            color: "#00000000",
            symbolColor: "#ffffff",
        },
        alwaysOnTop: savedSettings.always_on_top,
        darkTheme: theme.isDark,
        icon: "./root/icon.ico",
    })

    mainWindow.on("resize", () => {
        const [x, y] = mainWindow.getSize()
        sendIpc(mainWindow, "sizeChanged", { x, y })
    })
    mainWindow.on("focus", () => {
        sendIpc(mainWindow, "focusedChanged", { focused: true })
    })
    mainWindow.on("blur", () => {
        sendIpc(mainWindow, "focusedChanged", { focused: false })
    })

    const query = `?state=${btoa(JSON.stringify(savedState))}&settings=${btoa(
        JSON.stringify(savedSettings)
    )}&titlebar=${customTitlebar}&theme=${btoa(JSON.stringify(theme))}`

    await mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY + query)
    if (process.platform == "darwin") {
        mainWindow.setWindowButtonVisibility(true)
    }

    const directories = (
        await fs.readdir(themeDirectory, { withFileTypes: true })
    ).filter((x) => x.isDirectory())
    for (const directory of directories) {
        const json = await fs.readFile(
            `${themeDirectory}${directory.name}/${directory.name}.json`,
            "utf8"
        )
        const obj = JSON.parse(json)
        availableThemes[directory.name] = themeFileToThemeData(
            directory.name,
            obj
        )
    }
    sendIpc(mainWindow, "updateAvailableThemes", Object.values(availableThemes))
}

onIpc("saveState", (event, state) => {
    saveState(state)
})

onIpc("updateAngleUnit", (event, angleUnit) => {
    savedSettings.angle_unit = angleUnit
    sendIpc(mainWindow, "updateSettings", savedSettings)
    saveSettings(savedSettings)
})

onIpc("updateTheme", async (event, theme) => {
    savedSettings.theme = theme
    sendIpc(mainWindow, "updateSettings", savedSettings)
    saveSettings(savedSettings)
})

app.setPath("userData", directory + "/electron")

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow)

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
        app.quit()
    }
})

app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow()
    }
})
